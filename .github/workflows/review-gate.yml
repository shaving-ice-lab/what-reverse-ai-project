name: Review Gate

on:
  pull_request:
    types:
      - opened
      - synchronize
      - reopened
      - labeled
      - unlabeled
      - ready_for_review
      - edited
    branches: [main, develop]

permissions:
  contents: read
  pull-requests: read

jobs:
  review-gate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Enforce review priority and critical gate
        uses: actions/github-script@v7
        with:
          script: |
            const requiredPriorityLabels = ['review/p0', 'review/p1', 'review/p2'];
            const criticalLabel = 'merge-gate/critical';
            const defaultCriticalOwnerGroups = [
              '@shaving-ice-lab/security',
              '@shaving-ice-lab/db',
              '@shaving-ice-lab/devops',
            ];
            const defaultBaseCriticalApprovals = 2;

            const stripBOM = (value) => value.replace(/^\uFEFF/, '');
            const escapeRegex = (input) =>
              input.replace(/[|\\{}()[\]^$+?.]/g, '\\$&');
            const escapeClassChar = (input) => {
              if (input === '\\') return '\\\\';
              if (input === ']') return '\\]';
              if (input === '^') return '\\^';
              return input;
            };

            const isCommentLine = (line) => {
              const trimmed = line.trimStart();
              return trimmed.startsWith('#');
            };

            const tokenizeLine = (line) => {
              const tokens = [];
              let current = '';
              let escaping = false;
              for (let i = 0; i < line.length; i += 1) {
                const ch = line[i];
                if (escaping) {
                  current += ch;
                  escaping = false;
                  continue;
                }
                if (ch === '\\') {
                  escaping = true;
                  current += ch;
                  continue;
                }
                if (/\s/.test(ch)) {
                  if (current.length > 0) {
                    tokens.push(current);
                    current = '';
                  }
                  continue;
                }
                current += ch;
              }
              if (current.length > 0) {
                tokens.push(current);
              }
              return tokens;
            };

            const parseCriticalOwners = (content) => {
              const owners = [];
              const lines = content.split(/\r?\n/);
              for (const line of lines) {
                const match = line.match(/^\s*#\s*critical-owners:\s*(.+)$/);
                if (!match) continue;
                owners.push(...tokenizeLine(match[1]));
              }
              return owners.length > 0 ? owners : defaultCriticalOwnerGroups;
            };

            const parseBaseCriticalApprovals = (content) => {
              const lines = content.split(/\r?\n/);
              for (const line of lines) {
                const match = line.match(/^\s*#\s*critical-approvals-base:\s*(\d+)\s*$/);
                if (match) {
                  const value = Number.parseInt(match[1], 10);
                  if (Number.isFinite(value) && value > 0) {
                    return value;
                  }
                }
              }
              return defaultBaseCriticalApprovals;
            };

            const parseOwnerApprovalOverrides = (content) => {
              const overrides = new Map();
              const lines = content.split(/\r?\n/);
              for (const line of lines) {
                const match = line.match(/^\s*#\s*critical-owners-approvals:\s*(.+)$/);
                if (!match) continue;
                const tokens = tokenizeLine(match[1]);
                for (const token of tokens) {
                  const [owner, approvals] = token.split('=');
                  const value = Number.parseInt(approvals, 10);
                  if (owner && Number.isFinite(value) && value > 0) {
                    overrides.set(owner, value);
                  }
                }
              }
              return overrides;
            };

            const parseFileApprovalThresholds = (content) => {
              const thresholds = [];
              const lines = content.split(/\r?\n/);
              for (const line of lines) {
                const match = line.match(/^\s*#\s*critical-files-approvals:\s*(.+)$/);
                if (!match) continue;
                const tokens = tokenizeLine(match[1]);
                for (const token of tokens) {
                  const [thresholdRaw, approvalsRaw] = token.split('=');
                  const threshold = Number.parseInt(thresholdRaw, 10);
                  const approvals = Number.parseInt(approvalsRaw, 10);
                  if (
                    Number.isFinite(threshold) &&
                    threshold > 0 &&
                    Number.isFinite(approvals) &&
                    approvals > 0
                  ) {
                    thresholds.push({ threshold, approvals });
                  }
                }
              }
              return thresholds.sort((a, b) => a.threshold - b.threshold);
            };

            const parseCriticalGroupThresholds = (content) => {
              const thresholds = [];
              const lines = content.split(/\r?\n/);
              for (const line of lines) {
                const match = line.match(/^\s*#\s*critical-groups-approvals:\s*(.+)$/);
                if (!match) continue;
                const tokens = tokenizeLine(match[1]);
                for (const token of tokens) {
                  const [thresholdRaw, approvalsRaw] = token.split('=');
                  const threshold = Number.parseInt(thresholdRaw, 10);
                  const approvals = Number.parseInt(approvalsRaw, 10);
                  if (
                    Number.isFinite(threshold) &&
                    threshold > 0 &&
                    Number.isFinite(approvals) &&
                    approvals > 0
                  ) {
                    thresholds.push({ threshold, approvals });
                  }
                }
              }
              return thresholds.sort((a, b) => a.threshold - b.threshold);
            };

            const parseCriticalChangeThresholds = (content) => {
              const thresholds = [];
              const lines = content.split(/\r?\n/);
              for (const line of lines) {
                const match = line.match(/^\s*#\s*critical-changes-approvals:\s*(.+)$/);
                if (!match) continue;
                const tokens = tokenizeLine(match[1]);
                for (const token of tokens) {
                  const [thresholdRaw, approvalsRaw] = token.split('=');
                  const threshold = Number.parseInt(thresholdRaw, 10);
                  const approvals = Number.parseInt(approvalsRaw, 10);
                  if (
                    Number.isFinite(threshold) &&
                    threshold > 0 &&
                    Number.isFinite(approvals) &&
                    approvals > 0
                  ) {
                    thresholds.push({ threshold, approvals });
                  }
                }
              }
              return thresholds.sort((a, b) => a.threshold - b.threshold);
            };

            const parseModuleApprovals = (content) => {
              const rules = [];
              const lines = content.split(/\r?\n/);
              for (const line of lines) {
                const match = line.match(/^\s*#\s*module-approvals:\s*(.+)$/);
                if (!match) continue;
                const tokens = tokenizeLine(match[1]);
                for (const token of tokens) {
                  const separatorIndex = token.lastIndexOf('=');
                  if (separatorIndex <= 0 || separatorIndex === token.length - 1) {
                    continue;
                  }
                  const pattern = token.slice(0, separatorIndex);
                  const approvals = Number.parseInt(token.slice(separatorIndex + 1), 10);
                  if (!pattern || !Number.isFinite(approvals) || approvals <= 0) {
                    continue;
                  }
                  rules.push({
                    pattern,
                    approvals,
                    regex: patternToRegex(pattern),
                  });
                }
              }
              return rules;
            };

            const endsWithUnescapedSlash = (value) => {
              if (!value.endsWith('/')) return false;
              let backslashes = 0;
              for (let i = value.length - 2; i >= 0 && value[i] === '\\'; i -= 1) {
                backslashes += 1;
              }
              return backslashes % 2 === 0;
            };

            const splitPattern = (pattern) => {
              const segments = [];
              let current = '';
              let escaping = false;
              for (let i = 0; i < pattern.length; i += 1) {
                const ch = pattern[i];
                if (escaping) {
                  current += ch;
                  escaping = false;
                  continue;
                }
                if (ch === '\\') {
                  escaping = true;
                  current += ch;
                  continue;
                }
                if (ch === '/') {
                  segments.push(current);
                  current = '';
                  continue;
                }
                current += ch;
              }
              segments.push(current);
              return segments;
            };

            const compileSegment = (segment) => {
              let result = '';
              for (let i = 0; i < segment.length; i += 1) {
                const ch = segment[i];
                if (ch === '\\') {
                  if (i + 1 < segment.length) {
                    i += 1;
                    result += escapeRegex(segment[i]);
                  } else {
                    result += '\\\\';
                  }
                  continue;
                }
                if (ch === '*') {
                  if (segment[i + 1] === '*') {
                    result += '[^/]*';
                    i += 1;
                  } else {
                    result += '[^/]*';
                  }
                  continue;
                }
                if (ch === '?') {
                  result += '[^/]';
                  continue;
                }
                if (ch === '[') {
                  let j = i + 1;
                  let classContent = '';
                  if (segment[j] === '!') {
                    classContent += '^';
                    j += 1;
                  }
                  if (segment[j] === ']') {
                    classContent += '\\]';
                    j += 1;
                  }
                  for (; j < segment.length && segment[j] !== ']'; j += 1) {
                    let classChar = segment[j];
                    if (classChar === '\\' && j + 1 < segment.length) {
                      j += 1;
                      classChar = segment[j];
                    }
                    classContent += escapeClassChar(classChar);
                  }
                  if (j >= segment.length) {
                    result += '\\[';
                  } else {
                    result += `[${classContent}]`;
                    i = j;
                  }
                  continue;
                }
                result += escapeRegex(ch);
              }
              return result;
            };

            const compileSegments = (segments) => {
              let regex = '';
              for (let i = 0; i < segments.length; i += 1) {
                const segment = segments[i];
                if (segment === '**') {
                  if (i === segments.length - 1) {
                    regex += '(?:[^/]+/)*[^/]*';
                  } else {
                    regex += '(?:[^/]+/)*';
                  }
                  continue;
                }
                regex += compileSegment(segment);
                if (i < segments.length - 1) {
                  regex += '/';
                }
              }
              return regex;
            };

            const patternToRegex = (pattern) => {
              if (!pattern || pattern === '/') {
                return /^$/;
              }
              const anchored = pattern.startsWith('/');
              let normalized = anchored ? pattern.slice(1) : pattern;
              const dirOnly = endsWithUnescapedSlash(normalized);
              if (dirOnly) {
                normalized = normalized.slice(0, -1);
              }

              const segments = splitPattern(normalized);
              const hasSlash = segments.length > 1;
              const prefix = anchored || hasSlash ? '^' : '(^|.*/)';
              let regexBody = compileSegments(segments);

              if (dirOnly) {
                regexBody = regexBody.length > 0 ? `${regexBody}(?:/.*)?` : '.*';
              }

              return new RegExp(`${prefix}${regexBody}$`);
            };

            const pr = context.payload.pull_request;
            if (!pr) {
              core.setFailed('This workflow only runs for pull_request events.');
              return;
            }

            const labels = pr.labels.map((label) => label.name);
            const hasPriority = labels.some((label) => requiredPriorityLabels.includes(label));
            if (!hasPriority) {
              core.setFailed(
                `Missing review priority label. Add one of: ${requiredPriorityLabels.join(', ')}`
              );
              return;
            }

            const fs = require('fs');
            const path = require('path');
            const codeownersPath = path.join(
              process.env.GITHUB_WORKSPACE || '.',
              '.github',
              'CODEOWNERS'
            );
            if (!fs.existsSync(codeownersPath)) {
              core.setFailed(`CODEOWNERS not found at ${codeownersPath}`);
              return;
            }

            const codeownersContent = stripBOM(fs.readFileSync(codeownersPath, 'utf8'));
            const criticalOwnerGroups = parseCriticalOwners(codeownersContent);
            const baseCriticalApprovals = parseBaseCriticalApprovals(codeownersContent);
            const ownerApprovalOverrides = parseOwnerApprovalOverrides(codeownersContent);
            const fileApprovalThresholds = parseFileApprovalThresholds(codeownersContent);
            const groupApprovalThresholds = parseCriticalGroupThresholds(codeownersContent);
            const changeApprovalThresholds = parseCriticalChangeThresholds(codeownersContent);
            const moduleApprovalRules = parseModuleApprovals(codeownersContent);
            const criticalOwnerGroupsSet = new Set(criticalOwnerGroups);
            const rules = codeownersContent
              .split(/\r?\n/)
              .filter((line) => line.trim().length > 0)
              .filter((line) => !isCommentLine(line))
              .map((line) => tokenizeLine(line))
              .filter((parts) => parts.length >= 1)
              .map((parts) => {
                let rawPattern = parts[0];
                let negate = false;
                if (rawPattern.startsWith('!') && !rawPattern.startsWith('\\!')) {
                  negate = true;
                  rawPattern = rawPattern.slice(1);
                }
                return {
                  pattern: rawPattern,
                  owners: parts.slice(1),
                  negate,
                  regex: patternToRegex(rawPattern),
                };
              })
              .filter((rule) => rule.pattern.length > 0)
              .filter((rule) => rule.negate || rule.owners.length > 0);

            const matchOwners = (filename) => {
              let owners = [];
              for (const rule of rules) {
                if (!rule.regex.test(filename)) {
                  continue;
                }
                if (rule.negate) {
                  owners = [];
                } else {
                  owners = rule.owners;
                }
              }
              return owners;
            };

            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              per_page: 100,
            });
            const criticalFiles = [];
            const criticalGroupsTouched = new Set();
            const matchedModuleApprovals = new Map();
            let criticalChangesCount = 0;
            for (const file of files) {
              const filename = file.filename;
              const owners = matchOwners(filename);
              let isCritical = false;
              for (const owner of owners) {
                if (criticalOwnerGroupsSet.has(owner)) {
                  isCritical = true;
                  criticalGroupsTouched.add(owner);
                }
              }
              if (isCritical) {
                criticalFiles.push(filename);
                if (Number.isFinite(file.changes)) {
                  criticalChangesCount += file.changes;
                }
              }

              if (moduleApprovalRules.length > 0) {
                for (const rule of moduleApprovalRules) {
                  if (rule.regex.test(filename)) {
                    matchedModuleApprovals.set(rule.pattern, rule.approvals);
                  }
                }
              }
            }
            const criticalFilesCount = criticalFiles.length;
            const criticalGroupsCount = criticalGroupsTouched.size;
            const touchesCritical = criticalFilesCount > 0;
            const moduleApprovalsList = [...matchedModuleApprovals.entries()];
            const moduleRequiredApprovals =
              moduleApprovalsList.length > 0
                ? Math.max(...moduleApprovalsList.map(([, approvals]) => approvals))
                : 0;
            const gateRequired = touchesCritical || moduleApprovalsList.length > 0;
            const moduleSummary =
              moduleApprovalsList.length > 0
                ? moduleApprovalsList.map(([pattern, approvals]) => `${pattern}=${approvals}`)
                : [];

            if (!gateRequired) {
              core.info('No critical or module gates triggered.');
              return;
            }

            const criticalGroupsList = [...criticalGroupsTouched];
            let requiredApprovals = baseCriticalApprovals;
            for (const owner of criticalGroupsList) {
              const override = ownerApprovalOverrides.get(owner);
              if (Number.isFinite(override)) {
                requiredApprovals = Math.max(requiredApprovals, override);
              }
            }
            if (moduleRequiredApprovals > 0) {
              requiredApprovals = Math.max(requiredApprovals, moduleRequiredApprovals);
            }
            const appliedFileThresholds = [];
            const appliedGroupThresholds = [];
            const appliedChangeThresholds = [];
            for (const entry of fileApprovalThresholds) {
              if (criticalFilesCount >= entry.threshold) {
                requiredApprovals = Math.max(requiredApprovals, entry.approvals);
                appliedFileThresholds.push(`${entry.threshold}=${entry.approvals}`);
              }
            }
            for (const entry of groupApprovalThresholds) {
              if (criticalGroupsCount >= entry.threshold) {
                requiredApprovals = Math.max(requiredApprovals, entry.approvals);
                appliedGroupThresholds.push(`${entry.threshold}=${entry.approvals}`);
              }
            }
            for (const entry of changeApprovalThresholds) {
              if (criticalChangesCount >= entry.threshold) {
                requiredApprovals = Math.max(requiredApprovals, entry.approvals);
                appliedChangeThresholds.push(`${entry.threshold}=${entry.approvals}`);
              }
            }

            if (!labels.includes(criticalLabel)) {
              core.setFailed(
                `Critical/module paths touched. Add label "${criticalLabel}" and obtain at least ${requiredApprovals} approvals. Module approvals: ${
                  moduleSummary.length > 0 ? moduleSummary.join(', ') : 'none'
                }`
              );
              return;
            }

            const reviews = await github.paginate(github.rest.pulls.listReviews, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              per_page: 100,
            });

            const latestByUser = new Map();
            for (const review of reviews) {
              if (!review.user) continue;
              latestByUser.set(review.user.login, review.state);
            }

            const author = pr.user.login;
            const approvers = [...latestByUser.entries()]
              .filter(([login, state]) => state === 'APPROVED' && login !== author)
              .map(([login]) => login);

            if (approvers.length < requiredApprovals) {
              core.setFailed(
                `Critical/module paths require at least ${requiredApprovals} approvals (excluding author). Current approvals: ${
                  approvers.length
                }. Critical owner groups: ${
                  criticalGroupsList.join(', ') || 'none'
                }. Critical files: ${criticalFilesCount}. Critical changes: ${criticalChangesCount}. Module approvals: ${
                  moduleSummary.length > 0 ? moduleSummary.join(', ') : 'none'
                }`
              );
              return;
            }

            core.info(
              `Critical/module gate satisfied with ${approvers.length} approvals (required: ${requiredApprovals}). Critical files: ${criticalFiles.join(
                ', '
              )}. Critical owner groups: ${
                criticalGroupsList.join(', ') || 'none'
              }. Critical changes: ${criticalChangesCount}. Module approvals: ${
                moduleSummary.length > 0 ? moduleSummary.join(', ') : 'none'
              }. File thresholds: ${
                appliedFileThresholds.length > 0 ? appliedFileThresholds.join(', ') : 'none'
              }. Group thresholds: ${
                appliedGroupThresholds.length > 0 ? appliedGroupThresholds.join(', ') : 'none'
              }. Change thresholds: ${
                appliedChangeThresholds.length > 0 ? appliedChangeThresholds.join(', ') : 'none'
              }`
            );
